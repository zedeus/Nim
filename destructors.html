<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim Destructors and Move Semantics</title>
<style type="text/css" >
/*
Stylesheet for use with Docutils/rst2html.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.

Modified from Chad Skeeters' rst2html-style
https://bitbucket.org/cskeeters/rst2html-style/

Modified by Boyd Greenfield and narimiran
*/

html {
  font-size: 100%;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%; }

body {
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-weight: 400;
  font-size: 1.125em;
  line-height: 1.5;
  color: #222;
  background-color: #FCFCFC; }

/* Skeleton grid */
.container {
  position: relative;
  width: 100%;
  max-width: 1050px;
  margin: 0 auto;
  padding: 0;
  box-sizing: border-box; }

.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box;
  margin-left: 1%;
}

.column:first-child,
.columns:first-child {
  margin-left: 0; }

.three.columns {
  width: 19%; }

.nine.columns {
  width: 80.0%; }

.twelve.columns {
  width: 100%;
  margin-left: 0; }

@media screen and (max-width: 860px) {
  .three.columns {
    display: none;
  }
  .nine.columns {
    width: 98.0%;
  }
  body {
    font-size: 1em;
    line-height: 1.35;
  }
}

cite {
  font-style: italic !important; }


/* Nim search input */
div#searchInputDiv {
  margin-bottom: 1em;
}
input#searchInput {
  width: 80%;
}

/*
 * Some custom formatting for input forms.
 * This also fixes input form colors on Firefox with a dark system theme on Linux.
 */
input {
  -moz-appearance: none;
  color: #333;
  background-color: #f8f8f8;
  border: 1px solid #aaa;
  font-family: "Lato", "Helvetica Neue", "HelveticaNeue", Helvetica, Arial, sans-serif;
  font-size: 0.9em;
  padding: 6px;
}
input:focus {
  border: 1px solid #1fa0eb;
  box-shadow: 0 0 2px #1fa0eb;
}

/* Docgen styles */
/* Links */
a {
  color: #07b;
  text-decoration: none;
}

a span.Identifier {
  text-decoration: underline;
  text-decoration-color: #aab;
}

a.reference-toplevel {
  font-weight: bold;
}

a.toc-backref {
  text-decoration: none;
  color: #222; }

a.link-seesrc {
  color: #607c9f;
  font-size: 0.9em;
  font-style: italic; }

a:hover,
a:focus {
  color: #607c9f;
  text-decoration: underline; }

a:hover span.Identifier {
  color: #607c9f;
}


sub,
sup {
  position: relative;
  font-size: 75%;
  line-height: 0;
  vertical-align: baseline; }

sup {
  top: -0.5em; }

sub {
  bottom: -0.25em; }

img {
  width: auto;
  height: auto;
  max-width: 100%;
  vertical-align: middle;
  border: 0;
  -ms-interpolation-mode: bicubic; }

@media print {
  * {
    color: black !important;
    text-shadow: none !important;
    background: transparent !important;
    box-shadow: none !important; }

  a,
  a:visited {
    text-decoration: underline; }

  a[href]:after {
    content: " (" attr(href) ")"; }

  abbr[title]:after {
    content: " (" attr(title) ")"; }

  .ir a:after,
  a[href^="javascript:"]:after,
  a[href^="#"]:after {
    content: ""; }

  pre,
  blockquote {
    border: 1px solid #999;
    page-break-inside: avoid; }

  thead {
    display: table-header-group; }

  tr,
  img {
    page-break-inside: avoid; }

  img {
    max-width: 100% !important; }

  @page {
    margin: 0.5cm; }

  h1 {
    page-break-before: always; }

  h1.title {
    page-break-before: avoid; }

  p,
  h2,
  h3 {
    orphans: 3;
    widows: 3; }

  h2,
  h3 {
    page-break-after: avoid; }
}


p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

small {
  font-size: 85%; }

strong {
  font-weight: 600;
  font-size: 0.95em;
  color: #3c3c3c;
}

em {
  font-style: italic; }

h1 {
  font-size: 1.8em;
  font-weight: 400;
  padding-bottom: .25em;
  border-bottom: 1px solid #aaa;
  margin-top: 2.5em;
  margin-bottom: 1em;
  line-height: 1.2em; }

h1.title {
  padding-bottom: 1em;
  border-bottom: 0px;
  font-size: 2.5em;
  text-align: center;
  font-weight: 900;
  margin-top: 0.75em;
  margin-bottom: 0em;
}

h2 {
  font-size: 1.3em;
  margin-top: 2em; }

h2.subtitle {
  text-align: center; }

h3 {
  font-size: 1.125em;
  font-style: italic;
  margin-top: 1.5em; }

h4 {
  font-size: 1.125em;
  margin-top: 1em; }

h5 {
  font-size: 1.125em;
  margin-top: 0.75em; }

h6 {
  font-size: 1.1em; }


ul,
ol {
  padding: 0;
  margin-top: 0.5em;
  margin-left: 0.75em; }

ul ul,
ul ol,
ol ol,
ol ul {
  margin-bottom: 0;
  margin-left: 1.25em; }

li {
    list-style-type: circle;
}

ul.simple-boot li {
    list-style-type: none;
    margin-left: 0em;
    margin-bottom: 0.5em;
}

ol.simple > li, ul.simple > li {
  margin-bottom: 0.25em;
  margin-left: 0.4em }

ul.simple.simple-toc > li {
    margin-top: 1em;
}

ul.simple-toc {
  list-style: none;
  font-size: 0.9em;
  margin-left: -0.3em;
  margin-top: 1em; }

ul.simple-toc > li {
    list-style-type: none;
}

ul.simple-toc-section {
  list-style-type: circle;
  margin-left: 1em;
  color: #6c9aae; }


ol.arabic {
  list-style: decimal; }

ol.loweralpha {
  list-style: lower-alpha; }

ol.upperalpha {
  list-style: upper-alpha; }

ol.lowerroman {
  list-style: lower-roman; }

ol.upperroman {
  list-style: upper-roman; }

ul.auto-toc {
  list-style-type: none; }


dl {
  margin-bottom: 1.5em; }

dt {
  margin-bottom: -0.5em;
  margin-left: 0.0em; }

dd {
  margin-left: 2.0em;
  margin-bottom: 3.0em;
  margin-top: 0.5em; }


hr {
  margin: 2em 0;
  border: 0;
  border-top: 1px solid #aaa; }

blockquote {
  font-size: 0.9em;
  font-style: italic;
  padding-left: 0.5em;
  margin-left: 0;
  border-left: 5px solid #bbc;
}

.pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  font-weight: 500;
  font-size: 0.85em;
  background-color: #f0f3ff;
  padding-left: 3px;
  padding-right: 3px;
  border-radius: 4px;
}

pre {
  font-family: "Source Code Pro", Monaco, Menlo, Consolas, "Courier New", monospace;
  color: #222;
  font-weight: 500;
  display: inline-block;
  box-sizing: border-box;
  min-width: 100%;
  padding: 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-size: 0.85em;
  white-space: pre !important;
  overflow-y: hidden;
  overflow-x: visible;
  background-color: ghostwhite;
  border: 1px solid #dde;
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px; }

.pre-scrollable {
  max-height: 340px;
  overflow-y: scroll; }


/* Nim line-numbered tables */
.line-nums-table {
  width: 100%;
  table-layout: fixed; }

table.line-nums-table {
  border-radius: 4px;
  border: 1px solid #cccccc;
  background-color: ghostwhite;
  border-collapse: separate;
  margin-top: 15px;
  margin-bottom: 25px; }

.line-nums-table tbody {
  border: none; }

.line-nums-table td pre {
  border: none;
  background-color: transparent; }

.line-nums-table td.blob-line-nums {
  width: 28px; }

.line-nums-table td.blob-line-nums pre {
  color: #b0b0b0;
  -webkit-filter: opacity(75%);
  text-align: right;
  border-color: transparent;
  background-color: transparent;
  padding-left: 0px;
  margin-left: 0px;
  padding-right: 0px;
  margin-right: 0px; }


table {
  max-width: 100%;
  background-color: transparent;
  margin-top: 0.5em;
  margin-bottom: 1.5em;
  border-collapse: collapse;
  border-color: #ccc;
  border-spacing: 0;
  font-size: 0.9em;
}

table th, table td {
  padding: 0px 0.5em 0px;
}

table th {
  background-color: #e8e8e8;
  font-weight: bold; }

table th.docinfo-name {
    background-color: transparent;
}

table tr:hover {
  background-color: ghostwhite; }


/* rst2html default used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0; }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 !important; }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 !important; }

.last, .with-subtitle {
  margin-bottom: 0 !important; }

.hidden {
  display: none; }

blockquote.epigraph {
  margin: 2em 5em; }

dl.docutils dd {
  margin-bottom: 0.5em; }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden; }


div.figure {
  margin-left: 2em;
  margin-right: 2em; }

div.footer, div.header {
  clear: both;
  text-align: center;
  color: #666;
  font-size: smaller; }

div.footer {
    padding-top: 5em;
}

div.line-block {
  display: block;
  margin-top: 1em;
  margin-bottom: 1em; }

div.line-block div.line-block {
  margin-top: 0;
  margin-bottom: 0;
  margin-left: 1.5em; }

div.topic {
  margin: 2em; }

div.search_results {
  background-color: antiquewhite;
  margin: 3em;
  padding: 1em;
  border: 1px solid #4d4d4d;
}

div#global-links ul {
  margin-left: 0;
  list-style-type: none;
}

div#global-links > simple-boot {
    margin-left: 3em;
}

hr.docutils {
  width: 75%; }

img.align-left, .figure.align-left, object.align-left {
  clear: left;
  float: left;
  margin-right: 1em; }

img.align-right, .figure.align-right, object.align-right {
  clear: right;
  float: right;
  margin-left: 1em; }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto; }

.align-left {
  text-align: left; }

.align-center {
  clear: both;
  text-align: center; }

.align-right {
  text-align: right; }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit; }

p.attribution {
  text-align: right;
  margin-left: 50%; }

p.caption {
  font-style: italic; }

p.credits {
  font-style: italic;
  font-size: smaller; }

p.label {
  white-space: nowrap; }

p.rubric {
  font-weight: bold;
  font-size: larger;
  color: maroon;
  text-align: center; }

p.topic-title {
  font-weight: bold; }

pre.address {
  margin-bottom: 0;
  margin-top: 0;
  font: inherit; }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em;
  margin-right: 2em; }

pre.code .ln {
  color: grey; }

/* line numbers */
pre.code, code {
  background-color: #eeeeee; }

pre.code .comment, code .comment {
  color: #5c6576; }

pre.code .keyword, code .keyword {
  color: #3B0D06;
  font-weight: bold; }

pre.code .literal.string, code .literal.string {
  color: #0c5404; }

pre.code .name.builtin, code .name.builtin {
  color: #352b84; }

pre.code .deleted, code .deleted {
  background-color: #DEB0A1; }

pre.code .inserted, code .inserted {
  background-color: #A3D289; }

span.classifier {
  font-style: oblique; }

span.classifier-delimiter {
  font-weight: bold; }

span.option {
  white-space: nowrap; }

span.problematic {
  color: #b30000; }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80%; }

span.DecNumber {
  color: #252dbe; }

span.BinNumber {
  color: #252dbe; }

span.HexNumber {
  color: #252dbe; }

span.OctNumber {
  color: #252dbe; }

span.FloatNumber {
  color: #252dbe; }

span.Identifier {
  color: #222; }

span.Keyword {
  font-weight: 600;
  color: #5e8f60; }

span.StringLit {
  color: #a4255b; }

span.LongStringLit {
  color: #a4255b; }

span.CharLit {
  color: #a4255b; }

span.EscapeSequence {
  color: black; }

span.Operator {
  color: black; }

span.Punctuation {
  color: black; }

span.Comment, span.LongComment {
  font-style: italic;
  font-weight: 400;
  color: #484a86; }

span.RegularExpression {
  color: darkviolet; }

span.TagStart {
  color: darkviolet; }

span.TagEnd {
  color: darkviolet; }

span.Key {
  color: #252dbe; }

span.Value {
  color: #252dbe; }

span.RawData {
  color: #a4255b; }

span.Assembler {
  color: #252dbe; }

span.Preprocessor {
  color: #252dbe; }

span.Directive {
  color: #252dbe; }

span.Command, span.Rule, span.Hyperlink, span.Label, span.Reference,
span.Other {
  color: black; }

/* Pop type, const, proc, and iterator defs in nim def blocks */
dt pre > span.Identifier, dt pre > span.Operator {
  color: #155da4;
  font-weight: 700; }

dt pre > span.Keyword ~ span.Identifier, dt pre > span.Identifier ~ span.Identifier,
dt pre > span.Operator ~ span.Identifier, dt pre > span.Other ~ span.Identifier {
  color: inherit;
  font-weight: inherit; }

/* Nim sprite for the footer (taken from main page favicon) */
.nim-sprite {
  display: inline-block;
  height: 16px;
  width: 16px;
  background-position: 0 0;
  background-size: 16px 16px;
  -webkit-filter: opacity(50%);
  background-repeat: no-repeat;
  background-image: url("data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA==");
  margin-bottom: -5px; }

span.pragmadots {
  /* Position: relative frees us up to make the dots
  look really nice without fucking up the layout and
  causing bulging in the parent container */
  position: relative;
  /* 1px down looks slightly nicer */
  top: 1px;
  padding: 2px;
  background-color: #e8e8e8;
  border-radius: 4px;
  margin: 0 2px;
  cursor: pointer;
  font-size: 0.8em;
}

span.pragmadots:hover {
  background-color: #DBDBDB;
}
span.pragmawrap {
  display: none;
}

span.attachedType {
  display: none;
  visibility: hidden;
}
</style>

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim Destructors and Move Semantics</h1>
    <div class="row">
  <div class="three columns">
  <div id="global-links">
    <ul class="simple-boot">
      <li>
        <a href="manual.html">Manual</a>
      </li>
      <li>
        <a href="lib.html">Standard library</a>
      </li>
      <li>
        <a href="theindex.html">Index</a>
      </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <ul class="simple simple-toc" id="toc-list">
<li><a class="reference" id="about-this-document_toc" href="#about-this-document">About this document</a></li>
<li><a class="reference" id="motivating-example_toc" href="#motivating-example">Motivating example</a></li>
<li><a class="reference" id="lifetimeminustracking-hooks_toc" href="#lifetimeminustracking-hooks">Lifetime-tracking hooks</a></li>
<ul class="simple"><li><a class="reference" id="lifetimeminustracking-hooks-eqdestroy-hook_toc" href="#lifetimeminustracking-hooks-eqdestroy-hook"><tt class="docutils literal"><span class="pre">=destroy</span></tt> hook</a></li>
<li><a class="reference" id="lifetimeminustracking-hooks-eqsink-hook_toc" href="#lifetimeminustracking-hooks-eqsink-hook"><tt class="docutils literal"><span class="pre">=sink</span></tt> hook</a></li>
<li><a class="reference" id="lifetimeminustracking-hooks-eq-copy-hook_toc" href="#lifetimeminustracking-hooks-eq-copy-hook"><tt class="docutils literal"><span class="pre">=</span></tt> (copy) hook</a></li>
</ul><li><a class="reference" id="move-semantics_toc" href="#move-semantics">Move semantics</a></li>
<li><a class="reference" id="swap_toc" href="#swap">Swap</a></li>
<li><a class="reference" id="sink-parameters_toc" href="#sink-parameters">Sink parameters</a></li>
<li><a class="reference" id="rewrite-rules_toc" href="#rewrite-rules">Rewrite rules</a></li>
<li><a class="reference" id="object-and-array-construction_toc" href="#object-and-array-construction">Object and array construction</a></li>
<li><a class="reference" id="destructor-removal_toc" href="#destructor-removal">Destructor removal</a></li>
<li><a class="reference" id="self-assignments_toc" href="#self-assignments">Self assignments</a></li>
<li><a class="reference" id="lent-type_toc" href="#lent-type">Lent type</a></li>
<li><a class="reference" id="owned-refs_toc" href="#owned-refs">Owned refs</a></li>
<li><a class="reference" id="hook-lifting_toc" href="#hook-lifting">Hook lifting</a></li>
<li><a class="reference" id="hook-generation_toc" href="#hook-generation">Hook generation</a></li>
<li><a class="reference" id="nodestroy-pragma_toc" href="#nodestroy-pragma">nodestroy pragma</a></li>

</ul>

  </div>
  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Authors:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td> 0.20.99</td></tr>
</tbody></table>
<h1><a class="toc-backref" id="about-this-document" href="#about-this-document">About this document</a></h1><p>This document describes the upcoming Nim runtime which does not use classical GC algorithms anymore but is based on destructors and move semantics. The new runtime's advantages are that Nim programs become oblivious to the involved heap sizes and programs are easier to write to make effective use of multi-core machines. As a nice bonus, files and sockets and the like will not require manual <tt class="docutils literal"><span class="pre">close</span></tt> calls anymore.</p>
<p>This document aims to be a precise specification about how move semantics and destructors work in Nim.</p>

<h1><a class="toc-backref" id="motivating-example" href="#motivating-example">Motivating example</a></h1><p>With the language mechanisms described here a custom seq could be written as:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">myseq</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">UncheckedArray</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
    <span class="Identifier">dealloc</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># do nothing for self-assignments:</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">cap</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">cap</span>
  <span class="Keyword">if</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">cap</span> <span class="Operator">*</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span>
      <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># move assignment</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
  <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">cap</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">cap</span>
  <span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Operator">.</span><span class="Identifier">data</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">resize</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Identifier">inc</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">Natural</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">T</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">;</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">Natural</span><span class="Punctuation">;</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">assert</span> <span class="Identifier">i</span> <span class="Operator">&lt;</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">y</span>

<span class="Keyword">proc</span> <span class="Identifier">createSeq</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">elems</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">cap</span> <span class="Operator">=</span> <span class="Identifier">elems</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">=</span> <span class="Identifier">elems</span><span class="Operator">.</span><span class="Identifier">len</span>
  <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">=</span> <span class="Keyword">cast</span><span class="Punctuation">[</span><span class="Keyword">type</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">alloc</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">cap</span> <span class="Operator">*</span> <span class="Identifier">sizeof</span><span class="Punctuation">(</span><span class="Identifier">T</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.&lt;</span><span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">len</span><span class="Punctuation">:</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">elems</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">len</span><span class="Operator">*</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">myseq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">inline</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">len</span></pre>
<h1><a class="toc-backref" id="lifetimeminustracking-hooks" href="#lifetimeminustracking-hooks">Lifetime-tracking hooks</a></h1><p>The memory management for Nim's standard <tt class="docutils literal"><span class="pre">string</span></tt> and <tt class="docutils literal"><span class="pre">seq</span></tt> types as well as other standard collections is performed via so called &quot;Lifetime-tracking hooks&quot; or &quot;type-bound operators&quot;. There are 3 different hooks for each (generic or concrete) object type <tt class="docutils literal"><span class="pre">T</span></tt> (<tt class="docutils literal"><span class="pre">T</span></tt> can also be a <tt class="docutils literal"><span class="pre">distinct</span></tt> type) that are called implicitly by the compiler.</p>
<p>(Note: The word &quot;hook&quot; here does not imply any kind of dynamic binding or runtime indirections, the implicit calls are statically bound and potentially inlined.)</p>

<h2><a class="toc-backref" id="lifetimeminustracking-hooks-eqdestroy-hook" href="#lifetimeminustracking-hooks-eqdestroy-hook"><tt class="docutils literal"><span class="pre">=destroy</span></tt> hook</a></h2><p>A <tt class="docutils literal"><span class="pre">=destroy</span></tt> hook frees the object's associated memory and releases other associated resources. Variables are destroyed via this hook when they go out of scope or when the routine they were declared in is about to return.</p>
<p>The prototype of this hook for a type <tt class="docutils literal"><span class="pre">T</span></tt> needs to be:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">)</span></pre><p>The general pattern in <tt class="docutils literal"><span class="pre">=destroy</span></tt> looks like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># first check if 'x' was moved to somewhere else:</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">freeResource</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">field</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="Keyword">nil</span></pre>
<h2><a class="toc-backref" id="lifetimeminustracking-hooks-eqsink-hook" href="#lifetimeminustracking-hooks-eqsink-hook"><tt class="docutils literal"><span class="pre">=sink</span></tt> hook</a></h2><p>A <tt class="docutils literal"><span class="pre">=sink</span></tt> hook moves an object around, the resources are stolen from the source and passed to the destination. It is ensured that source's destructor does not free the resources afterwards by setting the object to its default value (the value the object's state started in). Setting an object <tt class="docutils literal"><span class="pre">x</span></tt> back to its default value is written as <tt class="docutils literal"><span class="pre">wasMoved(x)</span></tt>.</p>
<p>The prototype of this hook for a type <tt class="docutils literal"><span class="pre">T</span></tt> needs to be:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">source</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span></pre><p>The general pattern in <tt class="docutils literal"><span class="pre">=sink</span></tt> looks like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">source</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">)</span>
  <span class="Identifier">dest</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="Identifier">source</span><span class="Operator">.</span><span class="Identifier">field</span></pre><p><strong>Note</strong>: <tt class="docutils literal"><span class="pre">=sink</span></tt> does not need to check for self-assignments. How self-assignments are handled is explained later in this document.</p>

<h2><a class="toc-backref" id="lifetimeminustracking-hooks-eq-copy-hook" href="#lifetimeminustracking-hooks-eq-copy-hook"><tt class="docutils literal"><span class="pre">=</span></tt> (copy) hook</a></h2><p>The ordinary assignment in Nim conceptually copies the values. The <tt class="docutils literal"><span class="pre">=</span></tt> hook is called for assignments that couldn't be transformed into <tt class="docutils literal"><span class="pre">=sink</span></tt> operations.</p>
<p>The prototype of this hook for a type <tt class="docutils literal"><span class="pre">T</span></tt> needs to be:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">source</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span></pre><p>The general pattern in <tt class="docutils literal"><span class="pre">=</span></tt> looks like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">T</span><span class="Punctuation">;</span> <span class="Identifier">source</span><span class="Punctuation">:</span> <span class="Identifier">T</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># protect against self-assignments:</span>
  <span class="Keyword">if</span> <span class="Identifier">dest</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">!=</span> <span class="Identifier">source</span><span class="Operator">.</span><span class="Identifier">field</span><span class="Punctuation">:</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">)</span>
    <span class="Identifier">dest</span><span class="Operator">.</span><span class="Identifier">field</span> <span class="Operator">=</span> <span class="Identifier">duplicateResource</span><span class="Punctuation">(</span><span class="Identifier">source</span><span class="Operator">.</span><span class="Identifier">field</span><span class="Punctuation">)</span></pre><p>The <tt class="docutils literal"><span class="pre">=</span></tt> proc can be marked with the <tt class="docutils literal"><span class="pre">{.error.}</span></tt> pragma. Then any assignment that otherwise would lead to a copy is prevented at compile-time.</p>

<h1><a class="toc-backref" id="move-semantics" href="#move-semantics">Move semantics</a></h1><p>A &quot;move&quot; can be regarded as an optimized copy operation. If the source of the copy operation is not used afterwards, the copy can be replaced by a move. This document uses the notation <tt class="docutils literal"><span class="pre">lastReadOf(x)</span></tt> to describe that <tt class="docutils literal"><span class="pre">x</span></tt> is not used afterwards. This property is computed by a static control flow analysis but can also be enforced by using <tt class="docutils literal"><span class="pre">system.move</span></tt> explicitly.</p>

<h1><a class="toc-backref" id="swap" href="#swap">Swap</a></h1><p>The need to check for self-assignments and also the need to destroy previous objects inside <tt class="docutils literal"><span class="pre">=</span></tt> and <tt class="docutils literal"><span class="pre">=sink</span></tt> is a strong indicator to treat <tt class="docutils literal"><span class="pre">system.swap</span></tt> as a builtin primitive of its own that simply swaps every field in the involved objects via <tt class="docutils literal"><span class="pre">copyMem</span></tt> or a comparable mechanism. In other words, <tt class="docutils literal"><span class="pre">swap(a, b)</span></tt> is <strong>not</strong> implemented as <tt class="docutils literal"><span class="pre">let tmp = move(a); b = move(a); a = move(tmp)</span></tt>.</p>
<p>This has further consequences:</p>
<ul class="simple"><li>Objects that contain pointers that point to the same object are not supported by Nim's model. Otherwise swapped objects would end up in an inconsistent state.</li>
<li>Seqs can use <tt class="docutils literal"><span class="pre">realloc</span></tt> in the implementation.</li>
</ul>

<h1><a class="toc-backref" id="sink-parameters" href="#sink-parameters">Sink parameters</a></h1><p>To move a variable into a collection usually <tt class="docutils literal"><span class="pre">sink</span></tt> parameters are involved. A location that is passed to a <tt class="docutils literal"><span class="pre">sink</span></tt> parameter should not be used afterwards. This is ensured by a static analysis over a control flow graph. If it cannot be proven to be the last usage of the location, a copy is done instead and this copy is then passed to the sink parameter.</p>
<p>A sink parameter <em>may</em> be consumed once in the proc's body but doesn't have to be consumed at all. The reason for this is that signatures like <tt class="docutils literal"><span class="pre">proc put(t: var Table; k: sink Key, v: sink Value)</span></tt> should be possible without any further overloads and <tt class="docutils literal"><span class="pre">put</span></tt> might not take owership of <tt class="docutils literal"><span class="pre">k</span></tt> if <tt class="docutils literal"><span class="pre">k</span></tt> already exists in the table. Sink parameters enable an affine type system, not a linear type system.</p>
<p>The employed static analysis is limited and only concerned with local variables; however object and tuple fields are treated as separate entities:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">consume</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">Obj</span><span class="Punctuation">)</span> <span class="Operator">=</span> <span class="Keyword">discard</span> <span class="StringLit">&quot;no implementation&quot;</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">tup</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
  <span class="Identifier">consume</span> <span class="Identifier">tup</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span>
  <span class="Comment"># ok, only tup[0] was consumed, tup[1] is still alive:</span>
  <span class="Identifier">echo</span> <span class="Identifier">tup</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">]</span></pre><p>Sometimes it is required to explicitly <tt class="docutils literal"><span class="pre">move</span></tt> a value into its final position:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">dest</span><span class="Punctuation">,</span> <span class="Identifier">src</span><span class="Punctuation">:</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="DecNumber">10</span><span class="Punctuation">,</span> <span class="Identifier">string</span><span class="Punctuation">]</span>
  <span class="Comment"># ...</span>
  <span class="Keyword">for</span> <span class="Identifier">i</span> <span class="Keyword">in</span> <span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">dest</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">move</span><span class="Punctuation">(</span><span class="Identifier">src</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>An implementation is allowed, but not required to implement even more move optimizations (and the current implementation does not).</p>

<h1><a class="toc-backref" id="rewrite-rules" href="#rewrite-rules">Rewrite rules</a></h1><p><strong>Note</strong>: There are two different allowed implementation strategies:</p>
<ol class="simple"><li>The produced <tt class="docutils literal"><span class="pre">finally</span></tt> section can be a single section that is wrapped around the complete routine body.</li>
<li>The produced <tt class="docutils literal"><span class="pre">finally</span></tt> section is wrapped around the enclosing scope.</li>
</ol>
<p>The current implementation follows strategy (1). This means that resources are not destroyed at the scope exit, but at the proc exit.</p>
<pre>
var x: T; stmts
---------------             (destroy-var)
var x: T; try stmts
finally: `=destroy`(x)


g(f(...))
------------------------    (nested-function-call)
g(let tmp;
bitwiseCopy tmp, f(...);
tmp)
finally: `=destroy`(tmp)


x = f(...)
------------------------    (function-sink)
`=sink`(x, f(...))


x = lastReadOf z
------------------          (move-optimization)
`=sink`(x, z)
wasMoved(z)


v = v
------------------   (self-assignment-removal)
discard &quot;nop&quot;


x = y
------------------          (copy)
`=`(x, y)


f_sink(g())
-----------------------     (call-to-sink)
f_sink(g())


f_sink(notLastReadOf y)
--------------------------     (copy-to-sink)
(let tmp; `=`(tmp, y);
f_sink(tmp))


f_sink(lastReadOf y)
-----------------------     (move-to-sink)
f_sink(y)
wasMoved(y)</pre>

<h1><a class="toc-backref" id="object-and-array-construction" href="#object-and-array-construction">Object and array construction</a></h1><p>Object and array construction is treated as a function call where the function has <tt class="docutils literal"><span class="pre">sink</span></tt> parameters.</p>

<h1><a class="toc-backref" id="destructor-removal" href="#destructor-removal">Destructor removal</a></h1><p><tt class="docutils literal"><span class="pre">wasMoved(x);</span></tt> followed by a <tt class="docutils literal"><span class="pre">=destroy(x)</span></tt> operation cancel each other out. An implementation is encouraged to exploit this in order to improve efficiency and code sizes.</p>

<h1><a class="toc-backref" id="self-assignments" href="#self-assignments">Self assignments</a></h1><p><tt class="docutils literal"><span class="pre">=sink</span></tt> in combination with <tt class="docutils literal"><span class="pre">wasMoved</span></tt> can handle self-assignments but it's subtle.</p>
<p>The simple case of <tt class="docutils literal"><span class="pre">x = x</span></tt> cannot be turned into <tt class="docutils literal"><span class="pre">=sink(x, x); wasMoved(x)</span></tt> because that would lose <tt class="docutils literal"><span class="pre">x</span></tt>'s value. The solution is that simple self-assignments are simply transformed into an empty statement that does nothing.</p>
<p>The complex case looks like a variant of <tt class="docutils literal"><span class="pre">x = f(x)</span></tt>, we consider <tt class="docutils literal"><span class="pre">x = select(rand() &lt; 0.5, x, y)</span></tt> here:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">select</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">;</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span> <span class="Comment"># moves a into result</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">b</span> <span class="Comment"># moves b into result</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="StringLit">&quot;abc&quot;</span>
  <span class="Keyword">var</span> <span class="Identifier">y</span> <span class="Operator">=</span> <span class="StringLit">&quot;xyz&quot;</span>
  <span class="Comment"># possible self-assignment:</span>
  <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">select</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">,</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">)</span></pre><p>Is transformed into:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">select</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">bool</span><span class="Punctuation">;</span> <span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Keyword">if</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
      <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">a</span><span class="Punctuation">)</span>
      <span class="Identifier">wasMoved</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span>
      <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
      <span class="Identifier">wasMoved</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">b</span><span class="Punctuation">)</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
  <span class="Keyword">try</span><span class="Punctuation">:</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="StringLit">&quot;abc&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">,</span> <span class="StringLit">&quot;xyz&quot;</span><span class="Punctuation">)</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">select</span><span class="Punctuation">(</span><span class="Identifier">true</span><span class="Punctuation">,</span>
      <span class="Keyword">let</span> <span class="Identifier">blitTmp</span> <span class="Operator">=</span> <span class="Identifier">x</span>
      <span class="Identifier">wasMoved</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
      <span class="Identifier">blitTmp</span><span class="Punctuation">,</span>
      <span class="Keyword">let</span> <span class="Identifier">blitTmp</span> <span class="Operator">=</span> <span class="Identifier">y</span>
      <span class="Identifier">wasMoved</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span>
      <span class="Identifier">blitTmp</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
    <span class="Identifier">echo</span> <span class="Punctuation">[</span><span class="Identifier">x</span><span class="Punctuation">]</span>
  <span class="Keyword">finally</span><span class="Punctuation">:</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">)</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span></pre><p>As can be manually verified, this transformation is correct for self-assignments.</p>

<h1><a class="toc-backref" id="lent-type" href="#lent-type">Lent type</a></h1><p><tt class="docutils literal"><span class="pre">proc p(x: sink T)</span></tt> means that the proc <tt class="docutils literal"><span class="pre">p</span></tt> takes ownership of <tt class="docutils literal"><span class="pre">x</span></tt>. To eliminate even more creation/copy &lt;-&gt; destruction pairs, a proc's return type can be annotated as <tt class="docutils literal"><span class="pre">lent T</span></tt>. This is useful for &quot;getter&quot; accessors that seek to allow an immutable view into a container.</p>
<p>The <tt class="docutils literal"><span class="pre">sink</span></tt> and <tt class="docutils literal"><span class="pre">lent</span></tt> annotations allow us to remove most (if not all) superfluous copies and destructions.</p>
<p><tt class="docutils literal"><span class="pre">lent T</span></tt> is like <tt class="docutils literal"><span class="pre">var T</span></tt> a hidden pointer. It is proven by the compiler that the pointer does not outlive its origin. No destructor call is injected for expressions of type <tt class="docutils literal"><span class="pre">lent T</span></tt> or of type <tt class="docutils literal"><span class="pre">var T</span></tt>.</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Tree</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">kids</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Tree</span><span class="Punctuation">]</span>

<span class="Keyword">proc</span> <span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Identifier">kids</span><span class="Punctuation">:</span> <span class="Identifier">sink</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Tree</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">Tree</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">Tree</span><span class="Punctuation">(</span><span class="Identifier">kids</span><span class="Punctuation">:</span> <span class="Identifier">kids</span><span class="Punctuation">)</span>
  <span class="Comment"># converted into:</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">kids</span><span class="Punctuation">,</span> <span class="Identifier">kids</span><span class="Punctuation">)</span><span class="Punctuation">;</span> <span class="Identifier">wasMoved</span><span class="Punctuation">(</span><span class="Identifier">kids</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">`</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">Tree</span><span class="Punctuation">;</span> <span class="Identifier">i</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">Tree</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kids</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Comment"># borrows from 'x', this is transformed into:</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">addr</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">kids</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span>
  <span class="Comment"># This means 'lent' is like 'var T' a hidden pointer.</span>
  <span class="Comment"># Unlike 'var' this hidden pointer cannot be used to mutate the object.</span>

<span class="Keyword">iterator</span> <span class="Identifier">children</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Identifier">Tree</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">lent</span> <span class="Identifier">Tree</span> <span class="Operator">=</span>
  <span class="Keyword">for</span> <span class="Identifier">x</span> <span class="Keyword">in</span> <span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">kids</span><span class="Punctuation">:</span> <span class="Keyword">yield</span> <span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Comment"># everything turned into moves:</span>
  <span class="Keyword">let</span> <span class="Identifier">t</span> <span class="Operator">=</span> <span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">construct</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">t</span><span class="Punctuation">[</span><span class="DecNumber">0</span><span class="Punctuation">]</span> <span class="Comment"># accessor does not copy the element!</span></pre>
<h1><a class="toc-backref" id="owned-refs" href="#owned-refs">Owned refs</a></h1><p>Let <tt class="docutils literal"><span class="pre">W</span></tt> be an <tt class="docutils literal"><span class="pre">owned ref</span></tt> type. Conceptually its hooks look like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">W</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">assert</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">refcount</span> <span class="Operator">==</span> <span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="StringLit">&quot;dangling unowned pointers exist!&quot;</span>
    <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">)</span>
    <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Keyword">nil</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">W</span><span class="Punctuation">;</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">W</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Punctuation">:</span> <span class="StringLit">&quot;owned refs can only be moved&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">W</span><span class="Punctuation">;</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">W</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Identifier">bitwiseCopy</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Comment"># raw pointer copy</span></pre><p>Let <tt class="docutils literal"><span class="pre">U</span></tt> be an unowned <tt class="docutils literal"><span class="pre">ref</span></tt> type. Conceptually its hooks look like:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">U</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span>
    <span class="Identifier">dec</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">refcount</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">U</span><span class="Punctuation">;</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">U</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Comment"># Note: No need to check for self-assignments here.</span>
  <span class="Keyword">if</span> <span class="Identifier">y</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">inc</span> <span class="Identifier">y</span><span class="Operator">.</span><span class="Identifier">refcount</span>
  <span class="Keyword">if</span> <span class="Identifier">x</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">dec</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">refcount</span>
  <span class="Identifier">bitwiseCopy</span> <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span> <span class="Comment"># raw pointer copy</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">sink</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">U</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">U</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment"># Note: Moves are not available.</span></pre>
<h1><a class="toc-backref" id="hook-lifting" href="#hook-lifting">Hook lifting</a></h1><p>The hooks of a tuple type <tt class="docutils literal"><span class="pre">(A, B, ...)</span></tt> are generated by lifting the hooks of the involved types <tt class="docutils literal"><span class="pre">A</span></tt>, <tt class="docutils literal"><span class="pre">B</span></tt>, ... to the tuple type. In other words, a copy <tt class="docutils literal"><span class="pre">x = y</span></tt> is implemented as <tt class="docutils literal"><span class="pre">x[0] = y[0]; x[1] = y[1]; ...</span></tt>, likewise for <tt class="docutils literal"><span class="pre">=sink</span></tt> and <tt class="docutils literal"><span class="pre">=destroy</span></tt>.</p>
<p>Other value-based compound types like <tt class="docutils literal"><span class="pre">object</span></tt> and <tt class="docutils literal"><span class="pre">array</span></tt> are handled correspondingly. For <tt class="docutils literal"><span class="pre">object</span></tt> however, the compiler generated hooks can be overridden. This can also be important to use an alternative traversal of the involved datastructure that is more efficient or in order to avoid deep recursions.</p>

<h1><a class="toc-backref" id="hook-generation" href="#hook-generation">Hook generation</a></h1><p>The ability to override a hook leads to a phase ordering problem:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Keyword">object</span>

<span class="Keyword">proc</span> <span class="Identifier">main</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Comment"># error: destructor for 'f' called here before</span>
  <span class="Comment"># it was seen in this module.</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Foo</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">discard</span></pre><p>The solution is to define <tt class="docutils literal"><span class="pre">proc `=destroy`[T](f: var Foo[T])</span></tt> before it is used. The compiler generates implicit hooks for all types in <em>strategic places</em> so that an explicitly provided hook that comes too &quot;late&quot; can be detected reliably. These <em>strategic places</em> have been derived from the rewrite rules and are as follows:</p>
<ul class="simple"><li>In the construct <tt class="docutils literal"><span class="pre">let/var x = ...</span></tt> (var/let binding) hooks are generated for <tt class="docutils literal"><span class="pre">typeof(x)</span></tt>.</li>
<li>In <tt class="docutils literal"><span class="pre">x = ...</span></tt> (assignment) hooks are generated for <tt class="docutils literal"><span class="pre">typeof(x)</span></tt>.</li>
<li>In <tt class="docutils literal"><span class="pre">f(...)</span></tt> (function call) hooks are generated for <tt class="docutils literal"><span class="pre">typeof(f(...))</span></tt>.</li>
<li>For every sink parameter <tt class="docutils literal"><span class="pre">x: sink T</span></tt> the hooks are generated for <tt class="docutils literal"><span class="pre">typeof(x)</span></tt>.</li>
</ul>

<h1><a class="toc-backref" id="nodestroy-pragma" href="#nodestroy-pragma">nodestroy pragma</a></h1><p>The experimental <span id="nodestroy_1">nodestroy</span> pragma inhibits hook injections. This can be used to specialize the object traversal in order to avoid deep recursions:</p>
<pre class="listing"><span class="Keyword">type</span> <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
  <span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int32</span>
  <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">owned</span> <span class="Identifier">Node</span>

<span class="Keyword">type</span> <span class="Identifier">Tree</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">root</span><span class="Punctuation">:</span> <span class="Identifier">owned</span> <span class="Identifier">Node</span>

<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">t</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">Tree</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodestroy</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Comment"># use an explicit stack so that we do not get stack overflows:</span>
  <span class="Keyword">var</span> <span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">owned</span> <span class="Identifier">Node</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Operator">@</span><span class="Punctuation">[</span><span class="Identifier">t</span><span class="Operator">.</span><span class="Identifier">root</span><span class="Punctuation">]</span>
  <span class="Keyword">while</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Operator">&gt;</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
    <span class="Keyword">let</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">pop</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">left</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">left</span><span class="Punctuation">)</span>
    <span class="Keyword">if</span> <span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">right</span> <span class="Operator">!=</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">right</span><span class="Punctuation">)</span>
    <span class="Comment"># free the memory explicit:</span>
    <span class="Identifier">dispose</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span>
  <span class="Comment"># notice how even the destructor for 's' is not called implicitly</span>
  <span class="Comment"># anymore thanks to .nodestroy, so we have to call it on our own:</span>
  <span class="Punctuation">`</span><span class="Operator">=</span><span class="Identifier">destroy</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span></pre><p>As can be seen from the example, this solution is hardly sufficient and should eventually be replaced by a better solution. </p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small>Made with Nim. Generated: 2019-09-23 11:39:57 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
